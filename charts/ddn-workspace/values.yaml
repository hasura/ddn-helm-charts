global:
  domain: ""
  subDomain: true
  containerRegistry: "gcr.io/hasura-ee"
  certIssuer: "letsencrypt-prod"
  uriScheme: "https"
  persistence:
    enabled: true
  serviceCatalog:
    - name: data
      port: 8080
    - name: ddn-cps-engine
      port: 3000
  serviceAccount:
    enabled: true
  routes:
    enabled: false

additionalLabels:
  group: ddn-workspace
  # ddn-id label will be added automatically when auth-proxy is enabled

networkPolicy:
  ingress:
    enabled: true
  egress:
    enabled: true
    allowedApps:
      - data
      - ddn-cps-engine

useReleaseName: true

# Container Configs
image:
  repository: "ddn-native-workspace"
  tag: ""

replicas: "1"
httpPort: 8123
setControlPlaneUrls: true

persistence:
  enabled: true
  size: 10Gi

homePersistence:
  enabled: false
  size: 10Gi
  accessMode: ReadWriteOnce
  # storageClassName: ""  # Optional: specify storage class
  # existingClaim: ""     # Optional: use existing PVC
  updateStrategy: "version-aware"  # Options: "once", "always", "version-aware"

healthChecks:
  enabled: true
  livenessProbe: |
    httpGet:
      path: /healthz
      port: 8123
  readinessProbe: |
    httpGet:
      path: /healthz
      port: 8123

securityContext:
  runAsUser: 10001
  fsGroup: 10001
  runAsNonRoot: true

containerSecurityContext:
  runAsNonRoot: true
  allowPrivilegeEscalation: false
  capabilities:
    drop:
    - ALL
  readOnlyRootFilesystem: false

resources: |
  requests:
    cpu: 500m
    memory: 2048Mi
  limits:
    memory: 2048Mi

hostAliases:
  - ip: "127.0.0.1"
    hostnames:
      - "local.hasura.dev"

dataHost: "http://data:8080"
ddnCpsEngineHost: "http://ddn-cps-engine:3000"
consoleUrl: ""
ddnPromptqlEndpoint: ""
skipTlsVerify: false
secrets:
  password: ""

# Additional Container Envs
env: |
  - name: CODE_SERVER_PORT
    value: "8123"
  {{- if not (include "ddn-workspace.workspaceAuthProxy.enabled" .) }}
  - name: HASHED_PASSWORD
    valueFrom:
      secretKeyRef:
        name: {{ include "common.secretsName" $ }}
        key: WORKSPACE_PASSWORD
  {{- else }}
  - name: CODE_SERVER_NO_AUTH
    value: "true"
  {{- end }}
  - name: HASURA_DDN_INSECURE_SKIP_TLS_VERIFY
    value: {{ .Values.skipTlsVerify | quote }}
  {{- if .Values.setControlPlaneUrls }}
  - name: HASURA_DDN_CONSOLE_HOST
    value: {{ required "DDN Console URL (.Values.consoleUrl) is required" .Values.consoleUrl | quote }}
  - name: HASURA_DDN_CONTROL_PLANE_HOST
    value: {{ required "Data URL is required" .Values.dataHost | quote }}
  - name: HASURA_DDN_CONNECTOR_HUB_REGISTRY_HOST
    value: {{ required "DDN CPS Engine URL is required" .Values.ddnCpsEngineHost | quote }}
  {{- if .Values.ddnPromptqlEndpoint }}
  - name: HASURA_DDN_PROMPTQL_ENDPOINT
    value: {{ .Values.ddnPromptqlEndpoint | quote }}
  - name: HASURA_DDN_PROMPTQL_CONSOLE_HOST
    value: {{ required "DDN Console URL (.Values.consoleUrl) is required" .Values.consoleUrl | quote }}
  {{- end }}
  {{- end }}

extraVolumes: |
  {{- if include "ddn-workspace.workspaceAuthProxy.enabled" . }}
  - name: auth-proxy-config
    configMap:
      name: {{ include "ddn-workspace.workspaceAuthProxy.name" . }}-config
  {{- end }}
  - name: ddn-workspace-data
  {{- if and (.Values.persistence).enabled (.Values.global.persistence).enabled }}
    persistentVolumeClaim:
      claimName: {{ include "common.name" . }}-data
  {{- else }}
    emptyDir: {}
  {{- end }}
  {{- if and (.Values.homePersistence).enabled (.Values.global.persistence).enabled }}
  - name: ddn-workspace-home
    persistentVolumeClaim:
      claimName: {{ include "common.name" . }}-home
  {{- end }}

extraVolumeMounts: |
  - name: ddn-workspace-data
    mountPath: "/workspace"
  {{- if and (.Values.homePersistence).enabled (.Values.global.persistence).enabled }}
  - name: ddn-workspace-home
    mountPath: "/home"
    subPath: home
  {{- end }}

# Ingress Configs
# enable ingress / routes only if there is no internal network connectivity
# between control plane and data planes
ingress:
  enabled: true
  ingressClassName: nginx
  hostName: '{{ template "ddn-workspace.domain" . }}'
  additionalAnnotations: '{{ template "ddn-workspace.ingress.annotations" . }}'
  path: '{{ template "ddn-workspace.path" . }}'

routes:
  enabled: false
# Service ports configuration - handled directly in service.yaml template
# No additional ports needed as conditional logic is in the service template

# Workspace Auth Proxy Configuration
workspaceAuthProxy:
  enabled: false  # Set to true to enable auth-proxy (secrets.password will be ignored)
  ddnId: ""  # DDN ID that identifies the data plane this workspace belongs to (required when auth-proxy is enabled)
  debug:
    enabled: false
  # Image Configuration
  image:
    repository: "ddn-workspace-auth-proxy"
    tag: "a61c52b"
    pullPolicy: IfNotPresent
  # Cookie Configuration
  cookie:
    name: "workspace-session"
    maxAge: 3600  # Session expiry in seconds (1 hour = 3600 seconds)
    # domain, path, and secure will be configured automatically based on global settings
  # Authentication Methods Configuration
  auth:
    # Comma-separated list of enabled auth methods: pat,oidc-access-token,oidc-id-token
    enabledMethods: "pat,oidc-access-token,oidc-id-token"
    ui:
      title: "DDN Workspace | Login"
  # Service Configuration (used by configmap and ingress)
  service:
    port: 8080      # Auth-proxy HTTP port
  # Resource Configuration
  resources:
    limits:
      cpu: 200m
      memory: 256Mi
    requests:
      cpu: 100m
      memory: 128Mi

# Extra containers (sidecars) - Auth Proxy (only when enabled)
extraContainers: |
  {{- if include "ddn-workspace.workspaceAuthProxy.enabled" . }}
  - name: auth-proxy
    image: "{{ .Values.global.containerRegistry }}/{{ .Values.workspaceAuthProxy.image.repository }}:{{ .Values.workspaceAuthProxy.image.tag }}"
    imagePullPolicy: {{ .Values.workspaceAuthProxy.image.pullPolicy }}
    ports:
      - name: auth-http
        containerPort: 8080
        protocol: TCP
      - name: auth-admin
        containerPort: 9901
        protocol: TCP
    livenessProbe:
      httpGet:
        path: /ready
        port: 9901
      initialDelaySeconds: 30
      periodSeconds: 10
    readinessProbe:
      httpGet:
        path: /ready
        port: 9901
      initialDelaySeconds: 5
      periodSeconds: 5
    resources:
      limits:
        cpu: 500m
        memory: 512Mi
      requests:
        cpu: 100m
        memory: 128Mi
    volumeMounts:
    - name: auth-proxy-config
      mountPath: /etc/envoy
      readOnly: true
    securityContext:
      runAsNonRoot: true
      allowPrivilegeEscalation: false
      capabilities:
        drop:
        - ALL
      readOnlyRootFilesystem: false
    env:
    - name: DATA_HOST
      value: {{ include "common.extractHost" .Values.dataHost | quote }}
    - name: WORKSPACE_NAME
      value: {{ include "common.name" . | quote }}
    - name: COOKIE_DOMAIN
      value: {{ .Values.workspaceAuthProxy.cookieDomain | default (include "ddn-workspace.workspaceAuthProxy.cookieDomain" .) | quote }}
    - name: COOKIE_NAME
      value: {{ .Values.workspaceAuthProxy.cookie.name }}
    - name: COOKIE_MAX_AGE
      value: {{ .Values.workspaceAuthProxy.cookie.maxAge | default 3600 | quote }}
    - name: ENABLED_AUTH_METHODS
      value: {{ .Values.workspaceAuthProxy.auth.enabledMethods | quote }}
    - name: DDN_ID
      value: {{ required "Error: workspaceAuthProxy.ddnId is required when auth-proxy is enabled!" .Values.workspaceAuthProxy.ddnId | quote }}
    command: ["/usr/local/bin/envoy"]
    args: ["-c", "/etc/envoy/envoy.yaml", "--log-level", "{{ if .Values.workspaceAuthProxy.debug.enabled }}debug{{ else }}info{{ end }}"]
  {{- end }}

initContainers:
  extraInitContainers: |
    {{- if and (.Values.homePersistence).enabled (.Values.global.persistence).enabled }}
    - args:
      - |
        UPDATE_STRATEGY="{{ .Values.homePersistence.updateStrategy | default "version-aware" }}"
        IMAGE_VERSION="{{ .Values.image.tag }}"
        INITIALIZED_FILE="/persistent-home/.initialized"
        INITIALIZED_VERSION_FILE="/persistent-home/.image-version"

        echo "Home persistence update strategy: $UPDATE_STRATEGY"

        case "$UPDATE_STRATEGY" in
          "once")
            # Copy only once
            if [ ! -f "$INITIALIZED_FILE" ]; then
              echo "First run. Copying /home to persistent storage..."
              cp -a /home/. /persistent-home/
              touch "$INITIALIZED_FILE"
              echo "Copy complete"
            else
              echo "Persistent home already initialized (once strategy)"
            fi
            ;;
          "always")
            # Copy every time - only add new files, preserve existing
            echo "Always strategy - syncing /home to persistent storage..."
            cp -a --update=none /home/. /persistent-home/
            touch "$INITIALIZED_FILE"
            echo "Sync complete (always strategy)"
            ;;
          "version-aware")
            # Copy when image version changes - only add new files, preserve existing
            if [ ! -f "$INITIALIZED_VERSION_FILE" ] || [ "$(cat $INITIALIZED_VERSION_FILE 2>/dev/null)" != "$IMAGE_VERSION" ]; then
              echo "Image version changed or first run. Syncing /home to persistent storage..."
              cp -a --update=none /home/. /persistent-home/
              echo "$IMAGE_VERSION" > "$INITIALIZED_VERSION_FILE"
              touch "$INITIALIZED_FILE"
              echo "Sync complete for version $IMAGE_VERSION"
            else
              echo "Persistent home already up-to-date for version $IMAGE_VERSION"
            fi
            ;;
          *)
            echo "Unknown update strategy: $UPDATE_STRATEGY. Using 'version-aware' as fallback."
            if [ ! -f "$INITIALIZED_VERSION_FILE" ] || [ "$(cat $INITIALIZED_VERSION_FILE 2>/dev/null)" != "$IMAGE_VERSION" ]; then
              cp -a --update=none /home/. /persistent-home/
              echo "$IMAGE_VERSION" > "$INITIALIZED_VERSION_FILE"
              touch "$INITIALIZED_FILE"
              echo "Sync complete (fallback to version-aware strategy)"
            fi
            ;;
        esac
      command:
      - sh
      - -c
      image: "{{ .Values.global.containerRegistry }}/{{ .Values.image.repository }}:{{ .Values.image.tag }}"
      imagePullPolicy: {{ .Values.image.pullPolicy | default "IfNotPresent" }}
      name: copy-home
      resources: {}
      securityContext:
        allowPrivilegeEscalation: false
        readOnlyRootFilesystem: false
        runAsNonRoot: true
      terminationMessagePath: /dev/termination-log
      terminationMessagePolicy: File
      volumeMounts:
      - mountPath: /persistent-home
        name: ddn-workspace-home
        subPath: home
    {{- end }}
