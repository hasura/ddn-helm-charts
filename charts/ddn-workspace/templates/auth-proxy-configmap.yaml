{{- if include "ddn-workspace.workspaceAuthProxy.enabled" . }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "ddn-workspace.workspaceAuthProxy.name" . }}-config
  labels:
    {{- include "common.labels" . | nindent 4 }}
    component: auth-proxy
data:
  envoy.yaml: |
    admin:
      address:
        socket_address:
          protocol: TCP
          address: 0.0.0.0
          port_value: {{ .Values.workspaceAuthProxy.service.adminPort }}
    static_resources:
      listeners:
      - name: listener_0
        address:
          socket_address:
            address: 0.0.0.0
            port_value: {{ .Values.workspaceAuthProxy.service.port }}
        filter_chains:
        - filters:
          - name: envoy.filters.network.http_connection_manager
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
              stat_prefix: ingress_http
              upgrade_configs:
                - upgrade_type: websocket
              codec_type: AUTO
              # Enable access logging to see request routing
              access_log:
              - name: envoy.access_loggers.stdout
                typed_config:
                  "@type": type.googleapis.com/envoy.extensions.access_loggers.stream.v3.StdoutAccessLog
                  log_format:
                    text_format: |
                      [%START_TIME%] "%REQ(:METHOD)% %REQ(X-ENVOY-ORIGINAL-PATH?:PATH)% %PROTOCOL%"
                      %RESPONSE_CODE% %RESPONSE_FLAGS% %BYTES_RECEIVED% %BYTES_SENT%
                      %DURATION% %RESP(X-ENVOY-UPSTREAM-SERVICE-TIME)% "%REQ(X-FORWARDED-FOR)%"
                      "%REQ(USER-AGENT)%" "%REQ(X-REQUEST-ID)%" "%REQ(:AUTHORITY)%" "%UPSTREAM_HOST%"
                      upstream_cluster="%UPSTREAM_CLUSTER%" upstream_local_address="%UPSTREAM_LOCAL_ADDRESS%"
              route_config:
                name: local_route
                max_direct_response_body_size_bytes: 3672040
                virtual_hosts:
                - name: local_service
                  domains: ["*"]
                  routes:
                  {{- if .Values.global.subDomain }}
                  # Subdomain routing - direct paths
                  # Authentication endpoint - handled by Lua filter
                  - match:
                      path: "/auth"
                    route:
                      cluster: workspace_service
                      timeout: 30s
                  {{- else }}
                  # Path-based routing - workspace prefix required
                  # Authentication endpoint - handled by Lua filter
                  - match:
                      path: "/{{ include "common.name" . }}/auth"
                    route:
                      cluster: workspace_service
                      timeout: 30s
                      prefix_rewrite: "/auth"
                  {{- end }}
                    response_headers_to_add:
                      {{- include "ddn-workspace.securityHeaders" . | nindent 22 }}

                  # UI Static Assets - serve CSS and JS files (works for both modes due to ingress rewrite)
                  - match:
                      path: "/ui/client.js"
                    direct_response:
                      status: 200
                      body:
                        filename: "/var/www/html/client.js"
                    response_headers_to_add:
                      - header:
                          key: "Content-Type"
                          value: "application/javascript"
                      {{- include "ddn-workspace.securityHeaders" . | nindent 22 }}

                    # Skip Lua filter for static assets
                    typed_per_filter_config:
                      envoy.filters.http.lua:
                        "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.LuaPerRoute
                        disabled: true

                  - match:
                      path: "/ui/client.css"
                    direct_response:
                      status: 200
                      body:
                        filename: "/var/www/html/client.css"
                    response_headers_to_add:
                      - header:
                          key: "Content-Type"
                          value: "text/css"
                      {{- include "ddn-workspace.securityHeaders" . | nindent 22 }}

                    # Skip Lua filter for static assets
                    typed_per_filter_config:
                      envoy.filters.http.lua:
                        "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.LuaPerRoute
                        disabled: true

                  - match:
                      path: "/ui/output.css"
                    direct_response:
                      status: 200
                      body:
                        filename: "/var/www/html/output.css"
                    response_headers_to_add:
                      - header:
                          key: "Content-Type"
                          value: "text/css"
                      {{- include "ddn-workspace.securityHeaders" . | nindent 22 }}


                    # Skip Lua filter for static assets
                    typed_per_filter_config:
                      envoy.filters.http.lua:
                        "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.LuaPerRoute
                        disabled: true

                  # UI HTML - serve main page (works for both subdomain and path-based due to ingress rewrite)
                  - match:
                      path: "/ui"
                    direct_response:
                      status: 200
                      body:
                        filename: "/var/www/html/index.html"
                    response_headers_to_add:
                      - header:
                          key: "Content-Type"
                          value: "text/html"
                      {{- include "ddn-workspace.securityHeaders" . | nindent 22 }}


                    # Skip Lua filter for UI routes
                    typed_per_filter_config:
                      envoy.filters.http.lua:
                        "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.LuaPerRoute
                        disabled: true

                  # Default workspace routes
                  - match:
                      prefix: "/"
                    route:
                      cluster: workspace_service
                      timeout: 0s
                      max_stream_duration:
                        # this configuration will ensure
                        # that the stream is terminated after 60s
                        # so that if cookie expires, the connection is closed
                        max_stream_duration: {{ .Values.workspaceAuthProxy.cookie.maxAge | default 3600 }}s

              http_filters:
              # Lua filter for authentication
              - name: envoy.filters.http.lua
                typed_config:
                  "@type": type.googleapis.com/envoy.extensions.filters.http.lua.v3.Lua
                  inline_code: |
                    -- JSON encode/decode functions
                    package.path = package.path .. ";/usr/local/share/lua/5.1/?.lua"
                    package.cpath = package.cpath .. ";/usr/local/lib/lua/5.1/?.so"
                    local cjson = require "cjson"
                    local cookie_domain = os.getenv("COOKIE_DOMAIN") or ".localhost"
                    local cookie_max_age = os.getenv("COOKIE_MAX_AGE") or 3600
                    local config_workspace_name = os.getenv("WORKSPACE_NAME")
                    -- GraphQL workspace access check function
                    local function check_workspace_access(request_handle, token, auth_method, workspace_name)
                      local data_host = os.getenv("DATA_HOST") or "api.hasura.io"

                      local query_body = '{"query":"query fetchWorkspace($where: ddn_workspace_bool_exp!) { ddn_workspace(where: $where) { id password name } }","variables":{"where":{"name":{"_eq":"' .. workspace_name .. '"}}},"operationName":"fetchWorkspace"}'

                      local auth_header = auth_method .. " " .. token

                      local headers, body = request_handle:httpCall(
                        "graphql_cluster",
                        {
                          [":method"] = "POST",
                          [":path"] = "/v1/graphql",
                          [":authority"] = data_host,
                          ["content-type"] = "application/json",
                          ["authorization"] = auth_header
                        },
                        query_body,
                        5000
                      )
                      
                      if not body then
                        return false, "GraphQL request failed"
                      end
                      
                      local response = cjson.decode(body)
                      if response and response.data and response.data.ddn_workspace then
                        for i = 1, #response.data.ddn_workspace do
                          request_handle:logInfo("LUA SCRIPT: check_workspace_access: workspace: " .. cjson.encode(response.data.ddn_workspace[i]))
                          request_handle:logInfo("LUA SCRIPT: check_workspace_access: workspace_name: " .. workspace_name)
                          if response.data.ddn_workspace[i].name == workspace_name then
                            return true, nil
                          end
                        end
                      end
                      
                      if response and response.errors then
                        local error_msg = "GraphQL error"
                        if response.errors[1] and response.errors[1].message then
                          error_msg = response.errors[1].message
                        end
                        return false, error_msg
                      end
                      
                      return false, "No workspace access found"
                    end

                    function envoy_on_request(request_handle)
                      local path = request_handle:headers():get(":path")
                      local method = request_handle:headers():get(":method")

                      -- Ingress rewrites paths, so we always work with simple paths
                      local auth_path = "/auth"

                      if path == auth_path and method == "POST" then
                        local body = request_handle:body()
                        if not body then
                          request_handle:respond(
                            {[":status"] = "400", ["content-type"] = "application/json"},
                            '{"status":"error","message":"Missing request body"}'
                          )
                          return
                        end

                        local body_length = body:length()
                        if body_length == 0 then
                          request_handle:respond(
                            {[":status"] = "400", ["content-type"] = "application/json"},
                            '{"status":"error","message":"Empty request body"}'
                          )
                          return
                        end

                        local body_string = body:getBytes(0, body_length)
                        local request_data = cjson.decode(body_string)
                        if not request_data or not request_data.token or not request_data.auth_method then
                          request_handle:respond(
                            {[":status"] = "400", ["content-type"] = "application/json"},
                            '{"status":"error","message":"Missing token or auth_method"}'
                          )
                          return
                        end

                        local workspace_name = ""

                        -- this is the workspace user is trying to access
                        -- based on how ingress is forwarding it andit will most likely be
                        -- common.name.<domain> or <domain>/common.name
                        -- Remove -ddn-workspace suffix if present
                        workspace_name = string.gsub(config_workspace_name, "%-ddn%-workspace$", "")

                        local has_access, error_msg = check_workspace_access(
                          request_handle, request_data.token, request_data.auth_method, workspace_name
                        )


                        request_handle:logInfo("LUA SCRIPT: has_access: " .. tostring(has_access) .. ", error_msg: " .. (error_msg or "nil"))

                        if not has_access then
                          request_handle:respond(
                            {[":status"] = "403", ["content-type"] = "application/json"},
                            '{"status":"error","message":"Access denied"}'
                          )
                          return
                        end

                        {{- if .Values.global.subDomain }}
                        -- Subdomain routing: set cookie path to root
                        local cookie_path = "/"
                        {{- else }}
                        -- Path-based routing: set cookie path to workspace prefix (ingress handles the routing)
                        local cookie_path = "/" .. config_workspace_name 
                        {{- end }}
                        local cookie_value = "{{ .Values.workspaceAuthProxy.cookie.name }}=true; Domain=" .. cookie_domain .. "; Path=" .. cookie_path .. "; Max-Age=" .. cookie_max_age .. "; ; SameSite=Lax; Secure"

                        request_handle:logInfo("LUA SCRIPT: Setting authentication cookie: " .. cookie_value)
                        request_handle:respond(
                          {[":status"] = "200", ["content-type"] = "application/json", ["set-cookie"] = cookie_value},
                          '{"status":"success","message":"Authentication successful"}'
                        )
                        return
                      end

                      
                      local cookie_header = request_handle:headers():get("cookie")

                      cookie_name = "{{ .Values.workspaceAuthProxy.cookie.name }}"
                      request_handle:logInfo("LUA SCRIPT: Checking authentication for path: " .. path .. ", cookies: " .. (cookie_header or "none"))
                      if cookie_header == cookie_name .. "=true" then
                        request_handle:logInfo("LUA SCRIPT: Authentication cookie found, allowing access")
                        return
                      end

                      {{- if .Values.global.subDomain }}
                      request_handle:logInfo("LUA SCRIPT: Redirecting to /ui (subdomain mode)")
                      request_handle:respond({[":status"] = "302", ["location"] = "/ui"}, "")
                      {{- else }}
                      local redirect_location = "/" .. config_workspace_name .. "/ui"
                      request_handle:logInfo("LUA SCRIPT: Redirecting to " .. redirect_location .. " (path-based mode)")
                      request_handle:respond({[":status"] = "302", ["location"] = redirect_location}, "")
                      {{- end }}
                    end
              # Router Filter (must be last)
              - name: envoy.filters.http.router
                typed_config:
                  "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router

      clusters:
      - name: workspace_service
        connect_timeout: 0.25s
        type: LOGICAL_DNS
        lb_policy: ROUND_ROBIN
        load_assignment:
          cluster_name: workspace_service
          endpoints:
          - lb_endpoints:
            - endpoint:
                address:
                  socket_address:
                    address: 127.0.0.1
                    port_value: 8123
      
      - name: graphql_cluster
        connect_timeout: 5s
        type: LOGICAL_DNS
        dns_lookup_family: V4_ONLY
        # can I detect if http or https and set the port accordingly? based on dataHost?


{{- $dataURL := urlParse .Values.dataHost }}
{{- if eq $dataURL.scheme "https" }}
        transport_socket:
          name: envoy.transport_sockets.tls
          typed_config:
            "@type": type.googleapis.com/envoy.extensions.transport_sockets.tls.v3.UpstreamTlsContext
            common_tls_context: {}
            sni: {{ include "common.extractHost" .Values.dataHost }}
{{- end }}
        load_assignment:
          cluster_name: graphql_cluster
          endpoints:
          - lb_endpoints:
            - endpoint:
                address:
                  socket_address:
                    address: {{ include "common.extractHost" .Values.dataHost }}
                    port_value: {{ include "common.extractPort" .Values.dataHost | default "443" | int }}

{{- end }}
